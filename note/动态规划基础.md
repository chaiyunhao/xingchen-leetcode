## 动态规划基础

### 最长递增子序列（Longest Increasing Subsequence, LIS）

给定一个无序的整数数组，找到其中最长上升子序列长度


```java

public int lis(int[] nums){

  //初始化dp数组，默认值为1
  int[] dp = new int[nums.length];
  for(int i = 0; i < dp.length; i++){
    dp[i] = 1;
  }

  //对dp数组进行赋值
  for(int i = 0; i < nums.length; i++){
    for(int j = 0; j < i; j++){
      if(nums[i] > nums[j]){
        dp[i] = Math.max(dp[i], dp[j]+1);
      }
    }
  }

  //获取最大值
  int res = 0;
  for(int i = 0; i < dp.length; i++){
    res = Math.max(res, dp[i]);
  }
  return res;
}

```


### 0-1 背包问题

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

```java

public int bag(int[] wt, int[] val, int W){
  int N = wt.length;

  //初始化dp
  int[][] dp = new int[N+1][W+1];

  //背包重量为0，价值为0
  for(int i = 0; i <= N; i++){
    dp[i][0] = 0;
  }

  //物品重量为0，价值为0
  for(int i = 0; i <= W; i++){
    dp[0][W] = 0;
  }

  for(int j = 1; j <= W; j++){
    for(int i = 1; i <= N; i++){
      if(j - wt[i-1] < 0){
        dp[i][j] = dp[i-1][j];
      }else{
        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - wt[i-1]] + val[i-1]);
      }
    }
  }

  return dp[N][W];
}

```
